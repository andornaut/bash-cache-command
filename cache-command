#!/bin/bash

set -o errexit -o pipefail -o noclobber -o nounset

usage() {
    echo -n "Usage: $(basename "${0}") "
    echo '[--basedir=PATH] [--expiration=SECONDS] [--help] [--purge] [--remove] [--verbose] -- COMMAND'
}

baseDir="${XDG_RUNTIME_DIR-${HOME-/tmp}/.local/share}/cache-command"
expirationInSeconds=
purge=false
remove=false
verbose=false

# Arg parsing from: https://stackoverflow.com/a/29754866
OPTIONS=b:e:hprv
LONG_OPTS=basedir:,expiration:,help,purge,remove,verbose
! PARSED=$(getopt --options=${OPTIONS} --longoptions=${LONG_OPTS} --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    usage >/dev/stderr
    exit 1
fi

eval set -- "${PARSED}"
while true; do
    case "$1" in
        -b|--basedir)
            baseDir="$2"
            shift 2
            ;;
        -e|--expiration)
            expirationInSeconds="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit
            ;;
        -p|--purge)
            purge=true
            shift
            ;;
        -r|--remove)
            remove=true
            shift
            ;;
        -v|--verbose)
            verbose=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            usage >/dev/stderr
            exit 1
            ;;
    esac
done

# Remove basedir before validating the COMMAND argument, because the latter is moot in this case.
if [[ "${remove}" = true ]]; then
    [[ "${verbose}" = false ]] || echo "Removing basedir: ${baseDir}"
    rm -rf $([[ "${verbose}" = false ]] || echo -n '--verbose') "${baseDir}"
    exit
fi

if [[ $# -eq 0 ]]; then
    usage >/dev/stderr
    exit 1
fi

command="$@"
key="$(echo -n "${command}"|sha256sum)"

# Strip everything after the first word, because sha256sum adds a space (in text-mode) and filename
key=${key%% *}
cacheDir="${baseDir}/${key}"

if [[ "${verbose}" = true ]]; then
    echo "Base directory: ${baseDir}"
    echo "Cache directory: ${cacheDir}"
    echo "Command: ${command}"
    echo "Expiration in seconds: ${expirationInSeconds}"
    echo "Purge: ${purge}"
    echo "Remove: ${remove}"
    echo "Verbose: ${verbose}"
fi

removeCacheDir() {
    [[ "${verbose}" = false ]] || echo 'Purging cache'
    rm -rf $([[ "${verbose}" = false ]] || echo -n '--verbose') "${cacheDir}"
}

if [[ "${purge}" = true ]]; then
    removeCacheDir
    exit
fi

exitCodePath="${cacheDir}/exit-code"
errPath="${cacheDir}/stderr"
outPath="${cacheDir}/stdout"

cacheAge() {
    echo -n $(($(date +%s)-$(stat -c %Y "${exitCodePath}")))
}

if [[ -f "${exitCodePath}" ]]; then
    if [[ -z ${expirationInSeconds} || $(cacheAge) -lt ${expirationInSeconds} ]]; then
        [[ "${verbose}" = false ]] || echo "Using cache (cache age in seconds: $(cacheAge))"
        cat "${outPath}"
        cat "${errPath}" 1>&2
        exit $(cat "${exitCodePath}")
    fi

    [[ "${verbose}" = false ]] || echo "Cache has expired (cache age in seconds: $(cacheAge))"
    removeCacheDir
fi

mkdir -p "${cacheDir}"

# Executing the ${command} must be allowed to exit with a non-zero exit code
set +o errexit
${command} 2> >(tee "${errPath}" 1>&2) > >(tee "${outPath}")
exitCode=$?
echo -n ${exitCode} > "${exitCodePath}"
exit ${exitCode}
